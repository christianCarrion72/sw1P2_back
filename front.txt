import {
  ChangeDetectorRef,
  Component,
  ElementRef,
  OnInit,
  OnDestroy,
  ViewChild,
} from '@angular/core';
import { ActivatedRoute, Router, RouterModule } from '@angular/router';
import { SokectSevice } from '../../../services/socket.service';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { DragDropModule } from '@angular/cdk/drag-drop';
import { v4 as uuidv4 } from 'uuid';
import { HttpClient } from '@angular/common/http';
import { HttpClientModule } from '@angular/common/http';

interface DragState {
  isDragging: boolean;
  component: CanvasComponent | null;
  startX: number;
  startY: number;
  initialLeft: number;
  initialTop: number;
}

interface Page {
  id: string;
  name: string;
  components: CanvasComponent[];
}
interface ComponentDimensions {
  width: number;
  height: number;
}
interface CanvasComponent {
  id: string;
  type: string;
  top?: number;
  left?: number;
  width?: number;
  height?: number;
  decoration?: {
    color: string;
    border: {
      color: string;
      width?: number;
    };
    borderRadius: number;
  };
  text?: string;
  alignment?:
  | 'topLeft'
  | 'topCenter'
  | 'topRight'
  | 'centerLeft'
  | 'center'
  | 'centerRight'
  | 'bottomLeft'
  | 'bottomCenter'
  | 'bottomRight';

  options?: string[];
  icon?: string; // Nombre del icono, ej. "home_outlined"
  tooltip?: string; // Texto tooltip
  navigateTo?: string; // Ruta de navegaciÃ³n, ej. "/pantalla2"

  // NUEVAS para AppBar
  title?: string;
  centerTitle?: boolean;
  leading?: CanvasComponent | null;
  actions?: CanvasComponent[];

  children: CanvasComponent[];
  parentId: string | null;
  childrenLayout?: string;    // DisposiciÃ³n de los hijos (row o column)
  gap?: number;           // Espacio entre hijos (en px)
  selectedOption?: string; // OpciÃ³n actualmente seleccionada (para preview)

  fontSize?: number;
  textColor?: string; // Nueva propiedad para color de texto
  autoSize?: boolean; // Control para ajuste automÃ¡tico

  fontFamily?: string;
  textIndent?: number;
  textAlign?: 'left' | 'center' | 'right' | 'justify';

  // Nuevas propiedades para checkbox:
  checked?: boolean;
  checkColor?: string; // Color del check (âœ“)
  labelPosition?: 'left' | 'right' | 'top' | 'bottom';
  labelGap?: number; // Espacio entre checkbox y texto
  checkSize?: number; // TamaÃ±o interno del check (âœ“)
  onChangeAction?: string; // Nombre de la funciÃ³n a ejecutar al cambiar
  activeColor?: string;
  borderColor?: string; // Color del borde del checkbox
  borderWidth?: number;
  borderRadius?: number; // Radio del borde del checkbox
  scale?: number; // Factor de escala para el checkbox
  // Nuevas propiedades especÃ­ficas para TextField:
  labelText?: string;           // Texto del label
  hintText?: string;           // Texto placeholder
  value?: string;              // Valor actual del input
  inputType?: 'text' | 'email' | 'password' | 'number' | 'tel'; // Tipo de input
  maxLength?: number;          // Longitud mÃ¡xima
  enabled?: boolean;           // Si estÃ¡ habilitado o no
  obscureText?: boolean;       // Para passwords (ocultar texto)
  borderType?: 'outline' | 'underline' | 'none'; // Tipo de borde
  focusedBorderColor?: string; // Color del borde al hacer focus
  labelColor?: string;         // Color del label
  hintColor?: string;          // Color del hint/placeholder
  inputTextColor?: string;     // Color del texto de entrada
  backgroundColor?: string;    // Color de fondo del input
  // Nuevas propiedades para padding
  padding?: {
    top?: number;
    right?: number;
    bottom?: number;
    left?: number;
  };
  // O alternativamente, padding uniforme:
  paddingAll?: number;
}


interface ContextMenu {
  visible: boolean;
  x: number;
  y: number;
  targetId: string | null;
}

@Component({
  selector: 'app-rooms',
  standalone: true,
  imports: [CommonModule, FormsModule, RouterModule, DragDropModule, HttpClientModule],
  templateUrl: './rooms.component.html',
  styleUrls: ['./rooms.component.css'],
})
export class RoomsComponent implements OnInit, OnDestroy {
  @ViewChild('canvas', { static: false })
  canvasRef!: ElementRef<HTMLDivElement>;

  pages: Page[] = [];
  selectedComponent: CanvasComponent | null = null;
  contextMenu: ContextMenu = {
    visible: false,
    x: 0,
    y: 0,
    targetId: null,
  };

  components: CanvasComponent[] = [];
  private dragState: DragState = {
    isDragging: false,
    component: null,
    startX: 0,
    startY: 0,
    initialLeft: 0,
    initialTop: 0,
  };
  //instancias
  pantallaCustomRoute: string = '';

  isPreviewMode: boolean = false;
  previewPantallaIndex: number = 0;
  currentUserId: number = 0;

  dropdownSelectionMap: Record<string, string> = {};

  currentPantalla = 0;
  isModalFlutterCodeOpen: boolean = false;

  copiedComponent: CanvasComponent | null = null;
  cutMode: boolean = false;

  showResponseModal = false;
  httpResponse: any;

  showQuestionModal = false;
  questionText = '';

  selectedImage: File | null = null;
  imagePrompt: string = '';
  showImageModal: boolean = false;

  // Variables para grabaciÃ³n de audio
  isRecording: boolean = false;
  isProcessingAudio: boolean = false;
  mediaRecorder: MediaRecorder | null = null;
  audioChunks: Blob[] = [];
  recognition: any = null;

  //Find de instancias
  constructor(
    private route: ActivatedRoute,
    private sokectService: SokectSevice,
    private router: Router,
    private cdr: ChangeDetectorRef,
    private http: HttpClient
  ) { }
  ngOnDestroy(): void {
    throw new Error('Method not implemented.');
  }
  roomCode: string = '';
  roomName: string = '';
  roomId: number = 0;
  errorMessage: string = '';
  usersInRoom: any[] = [];
  showParticipants: boolean = false;
  ngOnInit(): void {
    this.roomCode = this.route.snapshot.paramMap.get('code') || '';

    if (this.roomCode) {
      this.sokectService.joinRoom(this.roomCode);
    }

    // Escucha el canvas inicial
    this.sokectService.onInitialCanvasLoad().subscribe((pages) => {
      this.pages = pages;

      if (pages.length === 0) {
        this.addPage(); // EmitirÃ¡ la creaciÃ³n por socket si es el primero
      } else {
        this.currentPantalla = 0;
      }

      this.cdr.detectChanges();
    });

    // Escucha nuevas pÃ¡ginas agregadas por otros usuarios
    this.sokectService.onPageAdded().subscribe((page: Page) => {
      const yaExiste = this.pages.some((p) => p.id === page.id);
      if (!yaExiste) {
        this.pages.push(page);
        this.currentPantalla = this.pages.length - 1;
        this.selectedComponent = null;
        this.cdr.detectChanges();
      }
    });
    this.sokectService.onPageRemoved().subscribe((pageId: string) => {
      this.pages = this.pages.filter((p) => p.id !== pageId);
      if (this.currentPantalla >= this.pages.length) {
        this.currentPantalla = this.pages.length - 1;
      }
      this.cdr.detectChanges();
    });
    // Escucha otras conexiones
    this.sokectService.onUsersListUpdate().subscribe((users) => {
      this.usersInRoom = users;
      this.cdr.detectChanges();
    });
    //addconteiner
    this.sokectService.onComponentAdded().subscribe(({ pageId, component }) => {
      const page = this.pages.find((p) => p.id === pageId);
      if (page) {
        page.components.push(component);
        this.selectedComponent = component;
        this.cdr.detectChanges();
      }
    });
    //actualizar propiedades de un widget
    this.sokectService
      .onComponentPropertiesUpdated()
      .subscribe(({ pageId, componentId, updates }) => {
        const page = this.pages.find(p => p.id === pageId);
        if (!page) return;

        const component = this.findComponentById(page.components, componentId);
        if (!component) return;

        // 1) Guardamos dimensiones previas
        const prevWidth = component.width;
        const prevHeight = component.height;

        // 2) Aplicamos los cambios
        const apply = (target: any, keys: string[], value: any) => {
          while (keys.length > 1) {
            const k = keys.shift()!;
            if (!(k in target)) target[k] = {};
            target = target[k];
          }
          target[keys[0]] = value;
        };

        let dimensionsChanged = false;
        Object.entries(updates).forEach(([key, value]) => {
          apply(component, key.split('.'), value);
          if (key === 'width' || key === 'height') {
            dimensionsChanged = true;
          }
        });

        if (dimensionsChanged) {
          const newWidth = component.width ?? 100;   // Valor por defecto si width es undefined
          const newHeight = component.height ?? 100;  // Valor por defecto si height es undefined
          const previousWidth = prevWidth ?? 100;    // Si prevWidth puede ser undefined
          const previousHeight = prevHeight ?? 100;  // Si prevHeight puede ser undefined
          const didGrow = (updates.width !== undefined && newWidth > previousWidth)
            || (updates.height !== undefined && newHeight > previousHeight);
          const didShrink = (updates.width !== undefined && newWidth < previousWidth)
            || (updates.height !== undefined && newHeight < previousHeight);

          // 3.a) Si es un HIJO que creciÃ³, hacemos crecer al padre (autoResizeParent nunca lo encoge)
          if (component.parentId && didGrow) {
            setTimeout(() => this.autoResizeParent(component.parentId!), 0);
          }

          // 3.b) Si es un PADRE que decreciÃ³, encogemos a sus hijos
          if (component.children?.length && didShrink) {
            setTimeout(() => this.autoShrinkChildren(component.id), 0);
          }
        }

        this.cdr.detectChanges();
      });

    //movimiento
    this.sokectService
      .onComponentMoved()
      .subscribe(({ pageId, componentId, newPosition }) => {
        const page = this.pages.find((p) => p.id === pageId);
        if (!page) return;

        const comp = this.findComponentById(page.components, componentId);

        if (!comp) return;

        // Actualizar posiciÃ³n visual
        comp.left = newPosition.left;
        comp.top = newPosition.top;

        this.cdr.detectChanges();
      });
    //eliminar widget;
    this.sokectService
      .onComponentRemoved()
      .subscribe(({ pageId, componentId }) => {
        console.log('ðŸ§¨ Recibido componentRemoved', { pageId, componentId });

        const page = this.pages.find((p) => p.id === pageId);
        if (page) {
          this.removeRecursive(page.components, componentId);
        }

        if (this.selectedComponent?.id === componentId) {
          this.selectedComponent = null;
        }

        this.contextMenu.visible = false;
        this.contextMenu.targetId = null;
        this.cdr.detectChanges();
      });
    //hijos
    this.sokectService
      .onChildComponentAdded()
      .subscribe(({ parentId, childComponent }) => {
        const page =
          this.pages[
          this.isPreviewMode
            ? this.previewPantallaIndex
            : this.currentPantalla
          ];

        const parent = this.findComponentById(page.components, parentId);
        if (parent) {
          if (!parent.children) parent.children = [];
          parent.children.push(childComponent);
          this.cdr.detectChanges();
        }
      });
    //fin hijos

    // Escuchar cuando se limpia una pÃ¡gina
    this.sokectService.onPageCleared().subscribe(({ pageId }) => {
      const page = this.pages.find((p) => p.id === pageId);
      if (page) {
        // Limpiar componentes de la pÃ¡gina
        page.components = [];

        // Si es la pÃ¡gina actual, deseleccionar componente
        if (page.id === this.pages[this.currentPantalla]?.id) {
          this.selectedComponent = null;
        }

        console.log(`ðŸ§¹ PÃ¡gina limpiada: ${page.name}`);
        this.cdr.detectChanges();
      }
    });

    //para el modo previsualizacion

    window.addEventListener('keydown', this.handleKeyDown.bind(this));
    document.addEventListener('click', this.handleDocumentClick.bind(this));
  }

  //para el panel izquierdo para agregar widgets al canvas
  getJsonCompleto(): string {
    // Limpia cada Page usando la misma lÃ³gica que para el cÃ³digo Dart
    const pantallasLimpias = this.pages.map((Page) => {
      const components = Page.components.map((comp) => {
        const clone: CanvasComponent = JSON.parse(JSON.stringify(comp));
        if (clone.alignment) {
          delete clone.top;
          delete clone.left;
        }
        return clone;
      });

      return {
        id: Page.id,
        name: Page.name,
        components,
      };
    });

    return JSON.stringify(pantallasLimpias, null, 2);
  }

  //agregar Page
  addPage(): void {
    const newPage: Page = {
      id: uuidv4(),
      name: `Pantalla ${this.pages.length + 1}`,
      components: [],
    };

    if (this.roomCode) {
      this.sokectService.addPage(this.roomCode, newPage);
    }
  }
  togglePreviewMode(): void {
    if (!this.isPreviewMode) {
      // Estoy a punto de entrar a PREVIEW: forzo que previewPantallaIndex === currentPantalla
      this.previewPantallaIndex = this.currentPantalla;
    } else {
      // Al salir de PREVIEW, sincronizo currentPantalla con previewPantallaIndex
      this.currentPantalla = this.previewPantallaIndex;
    }
    this.isPreviewMode = !this.isPreviewMode;
    this.cdr.detectChanges(); // Aseguramos que los cambios se reflejen correctamente
  }
  changePantalla(index: number): void {
    this.currentPantalla = index;
    this.selectedComponent = null;

    // Sincronizar siempre el Ã­ndice de previsualizaciÃ³n
    if (this.isPreviewMode) {
      this.previewPantallaIndex = index;
    }
    this.cdr.detectChanges();
  }

  removePage(pageId: string): void {
    if (!this.roomCode) return;

    // Eliminar la pÃ¡gina localmente
    this.pages = this.pages.filter((p) => p.id !== pageId);

    // Ajustar Ã­ndice actual si es necesario
    if (this.currentPantalla >= this.pages.length) {
      this.currentPantalla = Math.max(this.pages.length - 1, 0);
    }

    this.sokectService.removePage(this.roomCode, pageId);
    this.cdr.detectChanges();
  }












  addDropdownButton(): void {
    const newDropdown: CanvasComponent = {
      id: uuidv4(),
      type: 'DropdownButton',
      top: 50,
      left: 50,
      width: 120, // ancho inicial; puedes ajustar
      height: 40, // alto inicial
      decoration: {
        color: '#ffffff',
        border: { color: '#000000', width: 1 },
        borderRadius: 4,
      },
      options: ['OpciÃ³n 1', 'OpciÃ³n 2'], // dos opciones por defecto
      selectedOption: 'OpciÃ³n 1', // selecciona la primera por defecto
      children: [],
      parentId: null,
    };

    const pageId = this.pages[this.currentPantalla].id;
    this.sokectService.addCanvasComponent(this.roomCode, pageId, newDropdown);
  }
  //checkbox
  addCheckbox(): void {
    const defaultCheckSize = 24;
    const newCheckbox: CanvasComponent = {
      id: uuidv4(),
      type: 'Checkbox',

      // Propiedades especÃ­ficas del checkbox personalizado:
      checked: false,
      checkColor: '#FF0000', // Rojo (como tu checkColor)
      activeColor: '#FFFF00', // Amarillo (como tu activeColor)
      borderColor: '#FF0000', // Rojo (como tu side color)
      borderWidth: 2,
      borderRadius: 0, // Circular como tu shape
      scale: 2, // Factor de escala
      checkSize: defaultCheckSize, // TamaÃ±o base antes del scale
      children: [],
      parentId: null,
    };
    const pageId = this.pages[this.currentPantalla].id;
    this.sokectService.addCanvasComponent(this.roomCode, pageId, newCheckbox);
  }

  ///appbar
  /** Devuelve true si ya hay un AppBar en la pantalla actual */
  currentHasAppBar(): boolean {
    const page = this.pages[this.currentPantalla];
    return page.components.some(c => c.type === 'AppBar');
  }

  addAppBar(): void {
    if (this.currentHasAppBar()) {
      return; // ya existe uno, no agregamos otro
    }
    const newAppBar: CanvasComponent = {
      id: uuidv4(),
      type: 'AppBar',
      top: 0,
      left: 0,
      width: 360,
      height: 70,
      decoration: {
        color: '#2196f3',
        border: { color: '#000000', width: 0 },
        borderRadius: 0,
      },
      children: [],
      parentId: null,
    };
    const pageId = this.pages[this.currentPantalla].id;
    this.sokectService.addCanvasComponent(this.roomCode, pageId, newAppBar);
  }
  /** Llamada simple desde el botÃ³n cuando hay seleccionado */
  addTextRoot(): void {
    const pageId = this.pages[this.currentPantalla].id;

    const newText: CanvasComponent = {
      id: uuidv4(),
      type: 'Text',
      text: 'TÃ­tulo',
      fontSize: 16,
      autoSize: true,
      width: 44,
      height: 30,
      top: 10,
      left: 10,

      children: [],
      parentId: null,           // â† aquÃ­ lo dejamos sin padre
    };

    // Emitir al servidor como componente root
    this.sokectService.addCanvasComponent(
      this.roomCode,
      pageId,
      newText
    );

  }


  addContainer(): void {
    const newContainer: CanvasComponent = {
      id: uuidv4(),
      type: 'Container',
      top: 50,
      left: 50,
      width: 100,
      height: 100,
      decoration: {
        color: '#ffffff',
        border: {
          color: '#000000',
          width: 1,
        },
        borderRadius: 4,
      },
      children: [],
      parentId: null,
      childrenLayout: '',
      gap: 8,
    };
    const pageId = this.pages[this.currentPantalla].id;

    this.sokectService.addCanvasComponent(this.roomCode, pageId, newContainer);
  }

  addTextChild(parentId: string): void {
    const page =
      this.pages[
      this.isPreviewMode ? this.previewPantallaIndex : this.currentPantalla
      ];

    const parent = this.findComponentById(page.components, parentId);

    if (parent) {
      // Almacenar tamaÃ±o original del padre si no existe
      if (!this.originalParentSizes.has(parent.id)) {
        this.originalParentSizes.set(parent.id, {
          width: parent.width ?? 100,   // Valor por defecto si width es undefined
          height: parent.height ?? 100  // Valor por defecto si height es undefined
        });
      }
    }

    const padding = 0;

    const child: CanvasComponent = {
      id: uuidv4(),
      type: 'Text',
      text: 'TÃ­tulo',
      fontSize: 16,
      autoSize: true,
      width: 44,
      height: 30,
      top: padding,
      left: padding,
      decoration: {
        color: 'transparent',
        border: { color: '#000000', width: 0 },
        borderRadius: 0,
      },
      children: [],
      parentId,
    };

    this.sokectService.addChildComponent(this.roomCode, parentId, child, page.id);
    this.contextMenu.visible = false;

    // Ajustar tamaÃ±o del padre despuÃ©s de agregar hijo
    setTimeout(() => {
      this.autoResizeParent(parentId);
    }, 100);
  }

  addTextButton(): void {
    const buttonId = uuidv4();
    const newTextButton: CanvasComponent = {
      id: buttonId,
      type: 'TextButton',
      top: 50,
      left: 50,
      width: 120,      // ancho inicial
      height: 48,      // alto estÃ¡ndar
      decoration: {
        color: '#ffffff',
        border: { color: '#000000', width: 2 },
        borderRadius: 8,
      },
      navigateTo: '/pantalla2',
      text: 'BotÃ³n',
      textColor: '#000000',
      textAlign: 'center',
      fontSize: 16,
      fontFamily: 'inherit',
      children: [],
      parentId: null,
    };

    const pageId = this.pages[this.currentPantalla].id;
    this.sokectService.addCanvasComponent(this.roomCode, pageId, newTextButton);
  }

  // 2. MÃ©todo para agregar TextField:

  addTextField(): void {
    const newTextField: CanvasComponent = {
      id: uuidv4(),
      type: 'TextField',
      top: 50,
      left: 50,
      width: 200,
      height: 56, // Altura estÃ¡ndar para TextField
      decoration: {
        color: '#ffffff',
        border: {
          color: '#e0e0e0',
          width: 1,
        },
        borderRadius: 4,
      },
      hintText: 'Ingresa el texto aquÃ­',
      value: '',
      inputType: 'text',
      enabled: true,
      borderType: 'outline',
      focusedBorderColor: '#2196f3',
      labelColor: '#757575',
      hintColor: '#9e9e9e',
      inputTextColor: '#212121',
      fontSize: 16,
      children: [],
      parentId: null,
    };

    const pageId = this.pages[this.currentPantalla].id;
    this.sokectService.addCanvasComponent(this.roomCode, pageId, newTextField);
  }

  goToPantalla(ruta: string): void {
    const nombreRuta = ruta.replace('/', '');
    const index = this.pages.findIndex(
      (p) => p.name.toLowerCase().replace(/ /g, '') === nombreRuta
    );

    if (index !== -1) {
      this.previewPantallaIndex = index;
      this.currentPantalla = index; // Sincronizar ambos Ã­ndices
      this.cdr.detectChanges();
    }
  }
  //metodo par salir del modo previsualizacion con la tecla escape
  handleKeyDown(event: KeyboardEvent): void {
    if (event.key === 'Escape' && this.isPreviewMode) {
      this.isPreviewMode = false;
    }
  }

  //fin



















  //para el drag and drop o movimiento
  onMouseDown(event: MouseEvent, component: CanvasComponent): void {
    event.stopPropagation();
    this.selectedComponent = component;

    this.dragState = {
      isDragging: true,
      component,
      startX: event.clientX,
      startY: event.clientY,
      initialLeft: component.left ?? 0,
      initialTop: component.top ?? 0,
    };
  }
  onMouseMove(event: MouseEvent): void {
    if (!this.dragState.isDragging || !this.dragState.component) return;

    const deltaX = event.clientX - this.dragState.startX;
    const deltaY = event.clientY - this.dragState.startY;

    this.dragState.component.left = this.dragState.initialLeft + deltaX;
    this.dragState.component.top = this.dragState.initialTop + deltaY;

    this.cdr.detectChanges();
  }

  get currentPageId(): string {
    return this.pages[this.currentPantalla]?.id || '';
  }
  onMouseUp(event: MouseEvent): void {
    if (this.dragState.isDragging && this.dragState.component) {
      const comp = this.dragState.component;

      // Solo emitir si no hay alignment (se puede mover)
      if (!comp.alignment) {
        this.sokectService.moveComponent(
          this.roomCode,
          this.currentPageId,
          comp.id,
          {
            left: comp.left ?? 0,
            top: comp.top ?? 0,
            userId: this.currentUserId, // si lo necesitas en el backend
          }
        );
      }

      this.dragState.isDragging = false;
      this.dragState.component = null;
    }
  }
  //metodo par seleccionar un widget
  selectComponent(comp: CanvasComponent, event: MouseEvent): void {
    event.stopPropagation(); // evita que un hijo sobreescriba la selecciÃ³n del padre
    this.selectedComponent = comp;
    this.contextMenu.visible = false;
  }

  //metodos para el menu contextual donde se elimina el widget y otras opciones
  pastePosition: { x: number; y: number } | null = null;

  onRightClick(
    event: MouseEvent,
    component: CanvasComponent | null = null
  ): void {
    event.preventDefault();
    event.stopPropagation();

    const canvasRect = this.canvasRef.nativeElement.getBoundingClientRect();
    const x = event.clientX - canvasRect.left;
    const y = event.clientY - canvasRect.top;

    this.contextMenu = {
      visible: true,
      x,
      y,
      targetId: component?.id ?? null,
    };

    // Guardamos la posiciÃ³n del mouse para pegado libre
    this.pastePosition = component ? null : { x, y };
  }

  //metodo para cerrar el menu contextual
  handleDocumentClick(event: MouseEvent): void {
    // Si el menÃº estÃ¡ abierto y el clic no fue dentro del menÃº, lo cerramos
    const menu = document.getElementById('context-menu');
    if (
      this.contextMenu.visible &&
      menu &&
      !menu.contains(event.target as Node)
    ) {
      this.contextMenu.visible = false;
      this.contextMenu.targetId = null;
      this.cdr.detectChanges();
    }
  }

  //metodo recursivo para eliminar un widget

  removeComponent(id: string): void {
    const page = this.pages[this.currentPantalla];
    const pageId = page.id;

    this.sokectService.removeCanvasComponent(this.roomCode, pageId, id);
  }

  removeRecursive(list: CanvasComponent[], id: string): boolean {
    const index = list.findIndex((c) => c.id === id);
    if (index !== -1) {
      list.splice(index, 1);
      return true;
    }

    for (const comp of list) {
      if (comp.children) {
        const removed = this.removeRecursive(comp.children, id);
        if (removed) {
          return false;
        }
      }
    }

    return false;
  }

  copyComponent(comp: CanvasComponent): void {
    this.copiedComponent = JSON.parse(JSON.stringify(comp));
    this.cutMode = false;
    this.contextMenu.visible = false;
  }

  cutComponent(comp: CanvasComponent): void {
    this.copiedComponent = JSON.parse(JSON.stringify(comp));
    this.cutMode = true;
    this.contextMenu.visible = false;
  }
  onCanvasRightClick(event: MouseEvent): void {
    event.preventDefault();

    const canvasRect = this.canvasRef.nativeElement.getBoundingClientRect();
    const x = event.clientX - canvasRect.left;
    const y = event.clientY - canvasRect.top;

    this.contextMenu = {
      visible: true,
      x,
      y,
      targetId: null, // ðŸ‘ˆ Sin componente objetivo â†’ es canvas
    };
  }

  pasteComponent(parentId: string | null = null): void {
    if (!this.copiedComponent) return;

    const pasted = JSON.parse(JSON.stringify(this.copiedComponent));
    pasted.id = uuidv4();
    pasted.parentId = parentId;
    pasted.top = this.pastePosition?.y ?? 1;
    pasted.left = this.pastePosition?.x ?? 1;

    const pageId =
      this.pages[
        this.isPreviewMode ? this.previewPantallaIndex : this.currentPantalla
      ].id;

    // ðŸ§© Si hay parentId, es hijo â†’ usamos addChildComponent
    if (parentId && parentId !== '') {
      this.sokectService.addChildComponent(
        this.roomCode,
        parentId,
        pasted,
        pageId
      );
    } else {
      this.sokectService.addCanvasComponent(this.roomCode, pageId, pasted);
    }

    // ðŸ—‘ï¸ Si fue cortado, tambiÃ©n emitir removeComponent
    if (this.cutMode) {
      this.sokectService.removeCanvasComponent(
        this.roomCode,
        pageId,
        this.copiedComponent.id
      );
      this.cutMode = false;
    }

    this.copiedComponent = null;
    this.contextMenu.visible = false;
    this.pastePosition = null;
  }

  addChild(parentId: string): void {
    const page = this.pages[
      this.isPreviewMode ? this.previewPantallaIndex : this.currentPantalla
    ];
    const parent = this.findComponentById(page.components, parentId);

    if (parent) {
      // Almacenar tamaÃ±o original del padre si no existe
      if (!this.originalParentSizes.has(parent.id)) {
        this.originalParentSizes.set(parent.id, {
          width: parent.width ?? 100,   // Valor por defecto si width es undefined
          height: parent.height ?? 100  // Valor por defecto si height es undefined
        });
      }
    }

    const child: CanvasComponent = {
      id: uuidv4(),
      type: 'Container',
      width: 80,
      height: 80,
      top: 10,
      left: 10,
      decoration: {
        color: '#f0f0f0',
        border: { color: '#888888', width: 1 },
        borderRadius: 4,
      },
      children: [],
      parentId,
    };

    const pageId = page.id;

    this.sokectService.addChildComponent(
      this.roomCode,
      parentId,
      child,
      pageId
    );

    this.contextMenu.visible = false;

    // Ajustar tamaÃ±o del padre despuÃ©s de agregar hijo
    setTimeout(() => {
      this.autoResizeParent(parentId);
    }, 100);
  }


  findComponentById(
    list: CanvasComponent[],
    id: string
  ): CanvasComponent | null {
    for (const comp of list) {
      if (comp.id === id) return comp;
      if (comp.children?.length) {
        const found = this.findComponentById(comp.children, id);
        if (found) return found;
      }
    }
    return null;
  }

  /** Altura del AppBar si existe, o 0 */
  getReservedAppBarHeight(): number {
    const page = this.pages[
      this.isPreviewMode ? this.previewPantallaIndex : this.currentPantalla
    ];
    const appBar = page.components.find(c => c.type === 'AppBar');
    return appBar ? (appBar.height ?? 0) : 0;
  }
  hasParentLayout(comp: CanvasComponent): boolean {
    if (!comp.parentId) return false;
    const page = this.pages[this.currentPantalla];
    const parent = this.findComponentById(page.components, comp.parentId);
    return !!parent?.childrenLayout;
  }


  //metodo para previsualizar en el render, igualar el front con lo exportado en flutter
  getComponentStyle(comp: CanvasComponent): any {
    // â€”â€”â€” Valores por defecto para propiedades opcionales â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    const compWidth = comp.width ?? 100;
    const compHeight = comp.height ?? 100;

    // â€”â€”â€” 1) Datos de borde y sombra con decoration opcional â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    const decoration = comp.decoration ?? {
      color: 'transparent',
      border: { color: 'transparent', width: 0 },
      borderRadius: 0
    };

    const border = decoration.border ?? { color: 'transparent', width: 0 };
    const bw = border.width ?? 0;
    const bc = border.color ?? 'transparent';
    const inset = `inset 0 0 0 ${bw}px ${bc}`;

    const isSel = !this.isPreviewMode && this.selectedComponent?.id === comp.id;
    const ring = isSel ? `0 0 0 2px #2563eb` : '';
    const boxShadow = ring ? `${inset}, ${ring}` : inset;

    // â€”â€”â€” 2) Estilos base del contenedor â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    const style: any = {
      boxSizing: 'border-box',
      width: compWidth + 'px',
      height: compHeight + 'px',
      backgroundColor: decoration.color ?? 'transparent',
      boxShadow,
      borderRadius: (decoration.borderRadius ?? 0) + 'px',
      position: 'absolute',
      overflow: 'hidden',
      zIndex: comp.type === 'AppBar' ? 999 : 1,
    };

    // â€”â€”â€” 3) Estilos especÃ­ficos por tipo â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    if (comp.type === 'Text') {
      style.fontSize = (comp.fontSize ?? 16) + 'px';
      style.color = comp.textColor || '#000000';
      style.display = 'flex';
      style.alignItems = 'center';
      style.textOverflow = 'ellipsis';
      style.overflowWrap = 'break-word';
    }

    if (comp.type === 'Checkbox') {
      const baseSize = comp.checkSize || 24;
      const scale = comp.scale || 1;
      const scaledSize = baseSize * scale;
      style.width = scaledSize + 'px';
      style.height = scaledSize + 'px';
    }

    if (comp.type === 'TextField') {
      const minWidth = 120;
      const minHeight = 56;
      style.width = Math.max(compWidth, minWidth) + 'px';
      style.height = Math.max(compHeight, minHeight) + 'px';
      style.display = 'flex';
      style.flexDirection = 'column';
      style.justifyContent = 'center';
    }

    // â€”â€”â€” 4) Buscar padre â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    const pageIndex = this.isPreviewMode ? this.previewPantallaIndex : this.currentPantalla;
    const currentPage = this.pages[pageIndex];
    const parent = comp.parentId ? this.findComponentById(currentPage.components, comp.parentId) : null;

    // â€”â€”â€” 5) LÃ“GICA PARA ELEMENTOS HIJOS â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    if (parent) {
      const parentWidth = parent.width ?? 100;
      const parentHeight = parent.height ?? 100;

      // InformaciÃ³n del padre
      const parentDecoration = parent.decoration ?? {
        color: 'transparent',
        border: { color: 'transparent', width: 0 },
        borderRadius: 0
      };
      const parentBorder = parentDecoration.border ?? { color: 'transparent', width: 0 };
      const borderW = parentBorder.width ?? 0;

      // *** APLICAR PADDINGALL CORRECTAMENTE ***
      // Prioridad: paddingAll -> padding individual
      let paddingTop, paddingRight, paddingBottom, paddingLeft;

      if (parent.paddingAll !== undefined && parent.paddingAll > 0) {
        paddingTop = paddingRight = paddingBottom = paddingLeft = parent.paddingAll;
      } else {
        paddingTop = parent.padding?.top || 0;
        paddingRight = parent.padding?.right || 0;
        paddingBottom = parent.padding?.bottom || 0;
        paddingLeft = parent.padding?.left || 0;
      }

      // Espacio interior del padre
      const innerW = parentWidth - borderW * 2 - paddingLeft - paddingRight;
      const innerH = parentHeight - borderW * 2 - paddingTop - paddingBottom;

      // â€”â€”â€” CASO A: Padre SIN childrenLayout (posicionamiento absoluto tradicional) â€”â€”â€”
      if (!parent.childrenLayout) {
        // Limitar tamaÃ±o para que no sobresalga
        if (!comp.alignment) {
          const maxW = Math.max(0, innerW - (comp.left ?? 0));
          const maxH = Math.max(0, innerH - (comp.top ?? 0));
          style.width = Math.min(compWidth, maxW) + 'px';
          style.height = Math.min(compHeight, maxH) + 'px';
        } else {
          style.width = Math.min(compWidth, innerW) + 'px';
          style.height = Math.min(compHeight, innerH) + 'px';
        }

        // Calcular posiciÃ³n considerando padding
        let rawLeft: number, rawTop: number;
        if (!comp.alignment) {
          rawLeft = comp.left ?? 0;
          rawTop = comp.top ?? 0;
        } else {
          const usedWidth = parseFloat(style.width);
          const usedHeight = parseFloat(style.height);

          const x = {
            left: 0,
            center: (innerW - usedWidth) / 2,
            right: innerW - usedWidth,
          };
          const y = {
            top: 0,
            center: (innerH - usedHeight) / 2,
            bottom: innerH - usedHeight,
          };

          const alignmentMap: Record<string, { top: number; left: number }> = {
            topLeft: { top: y.top, left: x.left },
            topCenter: { top: y.top, left: x.center },
            topRight: { top: y.top, left: x.right },
            centerLeft: { top: y.center, left: x.left },
            center: { top: y.center, left: x.center },
            centerRight: { top: y.center, left: x.right },
            bottomLeft: { top: y.bottom, left: x.left },
            bottomCenter: { top: y.bottom, left: x.center },
            bottomRight: { top: y.bottom, left: x.right },
          };

          const pos = alignmentMap[comp.alignment];
          rawLeft = pos.left;
          rawTop = pos.top;
        }

        // Aplicar posiciÃ³n final considerando borde + padding del padre
        const finalLeft = borderW + paddingLeft + rawLeft;
        const finalTop = borderW + paddingTop + rawTop;

        // Clamp para mantener dentro del padre
        const usedW = parseFloat(style.width);
        const usedH = parseFloat(style.height);
        const maxLeft = parentWidth - usedW;
        const maxTop = parentHeight - usedH;

        style.left = Math.min(Math.max(finalLeft, borderW), maxLeft) + 'px';
        style.top = Math.min(Math.max(finalTop, borderW), maxTop) + 'px';
      }

      // â€”â€”â€” CASO B: Padre CON childrenLayout (flexbox) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
      else {
        // *** EXCEPCIÃ“N ESPECIAL PARA ELEMENTOS TEXT ***
        if (comp.type === 'Text') {
          // Los elementos Text mantienen posicionamiento absoluto incluso en contenedores flex
          style.width = Math.min(compWidth, innerW) + 'px';
          style.height = Math.min(compHeight, innerH) + 'px';
          style.position = 'absolute';

          let rawLeft: number, rawTop: number;

          if (!comp.alignment) {
            rawLeft = comp.left ?? 0;
            rawTop = comp.top ?? 0;
          } else {
            const usedWidth = parseFloat(style.width);
            const usedHeight = parseFloat(style.height);

            const x = {
              left: 0,
              center: (innerW - usedWidth) / 2,
              right: innerW - usedWidth,
            };
            const y = {
              top: 0,
              center: (innerH - usedHeight) / 2,
              bottom: innerH - usedHeight,
            };

            const alignmentMap: Record<string, { top: number; left: number }> = {
              topLeft: { top: y.top, left: x.left },
              topCenter: { top: y.top, left: x.center },
              topRight: { top: y.top, left: x.right },
              centerLeft: { top: y.center, left: x.left },
              center: { top: y.center, left: x.center },
              centerRight: { top: y.center, left: x.right },
              bottomLeft: { top: y.bottom, left: x.left },
              bottomCenter: { top: y.bottom, left: x.center },
              bottomRight: { top: y.bottom, left: x.right },
            };

            const pos = alignmentMap[comp.alignment] || { top: 0, left: 0 };
            rawLeft = pos.left;
            rawTop = pos.top;
          }

          // Aplicar posiciÃ³n considerando padding
          const finalLeft = borderW + paddingLeft + rawLeft;
          const finalTop = borderW + paddingTop + rawTop;

          const usedW = parseFloat(style.width);
          const usedH = parseFloat(style.height);
          const maxLeft = parentWidth - usedW;
          const maxTop = parentHeight - usedH;

          style.left = Math.min(Math.max(finalLeft, borderW), maxLeft) + 'px';
          style.top = Math.min(Math.max(finalTop, borderW), maxTop) + 'px';
          style.zIndex = 10;

          return style;
        }

        // *** RESTO DE ELEMENTOS (NO TEXT) - COMPORTAMIENTO FLEX NORMAL ***

        // Calcular tamaÃ±o mÃ¡ximo disponible considerando gaps
        const gap = parent.gap || 8;
        const siblings = parent.children || [];
        const flexSiblings = siblings.filter(sibling => sibling.type !== 'Text');
        const flexSiblingCount = flexSiblings.length;

        let maxAvailableW = innerW;
        let maxAvailableH = innerH;

        if (parent.childrenLayout === 'row' && flexSiblingCount > 1) {
          const totalGap = gap * (flexSiblingCount - 1);
          maxAvailableW = Math.max(0, (innerW - totalGap) / flexSiblingCount);
        } else if (parent.childrenLayout === 'column' && flexSiblingCount > 1) {
          const totalGap = gap * (flexSiblingCount - 1);
          maxAvailableH = Math.max(0, (innerH - totalGap) / flexSiblingCount);
        }

        // Aplicar lÃ­mites de tamaÃ±o
        style.width = Math.min(compWidth, maxAvailableW) + 'px';
        style.height = Math.min(compHeight, maxAvailableH) + 'px';

        // Configurar como elemento flex
        style.position = 'relative';
        delete style.left;
        delete style.top;

        // Si este elemento tambiÃ©n es contenedor flex
        if (comp.children && comp.children.length > 0 && comp.childrenLayout) {
          style.display = 'flex';
          style.flexDirection = comp.childrenLayout;
          style.justifyContent = this.getFlexJustifyContent(comp);
          style.alignItems = this.getFlexAlignItems(comp);
          style.gap = (comp.gap || 8) + 'px';

          // Padding del contenedor (respetando los bordes propios)
          const ownBorderW = bw;

          // Aplicar paddingAll correctamente para este contenedor
          let ownPaddingTop, ownPaddingRight, ownPaddingBottom, ownPaddingLeft;

          if (comp.paddingAll !== undefined && comp.paddingAll > 0) {
            ownPaddingTop = ownPaddingRight = ownPaddingBottom = ownPaddingLeft = comp.paddingAll;
          } else {
            ownPaddingTop = comp.padding?.top || 0;
            ownPaddingRight = comp.padding?.right || 0;
            ownPaddingBottom = comp.padding?.bottom || 0;
            ownPaddingLeft = comp.padding?.left || 0;
          }

          style.paddingTop = (ownPaddingTop + ownBorderW) + 'px';
          style.paddingRight = (ownPaddingRight + ownBorderW) + 'px';
          style.paddingBottom = (ownPaddingBottom + ownBorderW) + 'px';
          style.paddingLeft = (ownPaddingLeft + ownBorderW) + 'px';
        }

        // AlineaciÃ³n individual dentro del padre
        if (comp.alignment) {
          const flexAlignment = this.getFlexAlignment(comp.alignment, parent.childrenLayout);
          Object.assign(style, flexAlignment);
        }
      }

      return style;
    }

    // â€”â€”â€” 6) LÃ“GICA PARA ELEMENTOS PADRE (sin parentId) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
    const reserved = comp.type === 'AppBar' ? 0 : this.getReservedAppBarHeight();

    if (!comp.alignment) {
      style.left = (comp.left ?? 0) + 'px';
      style.top = ((comp.top ?? 0) + reserved) + 'px';
    } else {
      const canvasWidth = 360;
      const canvasHeight = 812;
      const availableHeight = canvasHeight - reserved;

      const x = {
        left: 0,
        center: (canvasWidth - compWidth) / 2,
        right: canvasWidth - compWidth,
      };
      const y = {
        top: reserved,
        center: reserved + (availableHeight - compHeight) / 2,
        bottom: canvasHeight - compHeight,
      };

      const alignmentMap: Record<string, { top: number; left: number }> = {
        topLeft: { top: y.top, left: x.left },
        topCenter: { top: y.top, left: x.center },
        topRight: { top: y.top, left: x.right },
        centerLeft: { top: y.center, left: x.left },
        center: { top: y.center, left: x.center },
        centerRight: { top: y.center, left: x.right },
        bottomLeft: { top: y.bottom, left: x.left },
        bottomCenter: { top: y.bottom, left: x.center },
        bottomRight: { top: y.bottom, left: x.right },
      };

      const pos = alignmentMap[comp.alignment];
      let left = Math.max(0, Math.min(pos.left, canvasWidth - compWidth));
      let top = Math.max(0, Math.min(pos.top, canvasHeight - compHeight));

      style.left = left + 'px';
      style.top = top + 'px';
    }

    return style;
  }

  // â€”â€”â€” MÃ‰TODOS AUXILIARES PARA FLEXBOX â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

  /* MÃ©todo para obtener justify-content del contenedor padre en este caso por mas
  que el padre este aliniado en cualquier posicion, sus hijos siempre estaran en el centro */
  getFlexJustifyContent(comp: CanvasComponent): string {
    if (!comp.alignment) return 'center'; // default

    if (comp.childrenLayout === 'row') {
      // En row, justify-content controla la alineaciÃ³n horizontal
      if (comp.alignment.includes('Left')) return 'center';
      if (comp.alignment.includes('Center')) return 'center';
      if (comp.alignment.includes('Right')) return 'center';
    } else if (comp.childrenLayout === 'column') {
      // En column, justify-content controla la alineaciÃ³n vertical
      if (comp.alignment.includes('top')) return 'center';
      if (comp.alignment.includes('center')) return 'center';
      if (comp.alignment.includes('bottom')) return 'center';
    }

    return 'center';
  }

  // MÃ©todo para obtener align-items del contenedor padre
  getFlexAlignItems(comp: CanvasComponent): string {
    if (!comp.alignment) return 'center'; // default

    if (comp.childrenLayout === 'row') {
      // En row, align-items controla la alineaciÃ³n vertical
      if (comp.alignment.startsWith('top')) return 'flex-start';
      if (comp.alignment.startsWith('center')) return 'center';
      if (comp.alignment.startsWith('bottom')) return 'flex-end';
    } else if (comp.childrenLayout === 'column') {
      // En column, align-items controla la alineaciÃ³n horizontal
      if (comp.alignment.includes('Left')) return 'flex-start';
      if (comp.alignment.includes('Center')) return 'center';
      if (comp.alignment.includes('Right')) return 'flex-end';
    }

    return 'center';
  }

  // MÃ©todo para obtener align-self de elementos hijos individuales
  private getFlexAlignment(alignment: string, parentLayout: string): any {
    const flexStyles: any = {};

    if (parentLayout === 'row') {
      // En layout horizontal (row), align-self controla la alineaciÃ³n vertical del elemento individual
      switch (alignment) {
        case 'topLeft':
        case 'topCenter':
        case 'topRight':
          flexStyles.alignSelf = 'flex-start';
          break;
        case 'centerLeft':
        case 'center':
        case 'centerRight':
          flexStyles.alignSelf = 'center';
          break;
        case 'bottomLeft':
        case 'bottomCenter':
        case 'bottomRight':
          flexStyles.alignSelf = 'flex-end';
          break;
      }
    } else if (parentLayout === 'column') {
      // En layout vertical (column), align-self controla la alineaciÃ³n horizontal del elemento individual
      switch (alignment) {
        case 'topLeft':
        case 'centerLeft':
        case 'bottomLeft':
          flexStyles.alignSelf = 'flex-start';
          break;
        case 'topCenter':
        case 'center':
        case 'bottomCenter':
          flexStyles.alignSelf = 'center';
          break;
        case 'topRight':
        case 'centerRight':
        case 'bottomRight':
          flexStyles.alignSelf = 'flex-end';
          break;
      }
    }

    return flexStyles;
  }


  //metodos auxiliares para agregar el componente textlabel
  // Agregar estas propiedades en tu componente
  private textFieldPreviewValues: Map<string, string> = new Map();

  // MÃ©todos para manejar valores temporales en modo previsualizaciÃ³n
  getTextFieldPreviewValue(componentId: string): string {
    return this.textFieldPreviewValues.get(componentId) || '';
  }

  setTextFieldPreviewValue(componentId: string, event: Event): void {
    const target = event.target as HTMLInputElement;
    this.textFieldPreviewValues.set(componentId, target.value);
  }

  // Opcional: Limpiar valores temporales cuando se sale del modo previsualizaciÃ³n
  clearTextFieldPreviewValues(): void {
    this.textFieldPreviewValues.clear();
  }

  // Si tienes un mÃ©todo que se ejecuta al cambiar de modo, puedes llamar clear allÃ­
  onPreviewModeChange(): void {
    if (!this.isPreviewMode) {
      this.clearTextFieldPreviewValues();
    }
  }
  getPantallaSinTopLeft(): CanvasComponent[] {
    return this.pages[this.currentPantalla].components.map((comp) => {
      const clone: CanvasComponent = JSON.parse(JSON.stringify(comp));

      if (clone.alignment) {
        delete clone.top;
        delete clone.left;
      }

      return clone;
    });
  }


  // MÃ©todos auxiliares para agregar a tu componente

  /**
   * Obtiene solo los hijos que participan en el flujo flex (excluye Text)
   */
  getFlexChildren(children: CanvasComponent[]): CanvasComponent[] {
    if (!children) return [];
    return children.filter(child => child.type !== 'Text');
  }

  /**
   * Obtiene solo los hijos de tipo Text
   */
  getTextChildren(children: CanvasComponent[]): CanvasComponent[] {
    if (!children) return [];
    return children.filter(child => child.type === 'Text');
  }







  //metodos auxiliares para ajustar tamaÃ±os
  /**
   * Valida y ajusta los tamaÃ±os de los hijos cuando el padre cambia de tamaÃ±o
   * considerando si tiene childrenLayout o no
   */
  private validateAndAdjustChildrenSizes(parentId: string): void {
    if (!parentId || !this.roomCode) return;

    const page = this.pages[this.currentPantalla];
    const parent = this.findComponentById(page.components, parentId);

    if (!parent || !parent.children?.length) return;

    const parentWidth = parent.width ?? 100;
    const parentHeight = parent.height ?? 100;
    const borderWidth = parent.decoration?.border?.width ?? 0;

    // Calcular padding efectivo
    const effectivePadding = this.getEffectivePadding(parent);

    // Espacio interior disponible considerando bordes y padding
    const availableWidth = parentWidth - (borderWidth * 2) - effectivePadding.left - effectivePadding.right;
    const availableHeight = parentHeight - (borderWidth * 2) - effectivePadding.top - effectivePadding.bottom;

    if (parent.childrenLayout === 'row') {
      this.validateRowLayoutChildren(parent, availableWidth, availableHeight);
    } else if (parent.childrenLayout === 'column') {
      this.validateColumnLayoutChildren(parent, availableWidth, availableHeight);
    } else {
      // Layout null/stack - usar validaciÃ³n de posicionamiento absoluto
      this.validateStackLayoutChildren(parent, availableWidth, availableHeight, effectivePadding, borderWidth);
    }
  }

  /**
   * Calcula el padding efectivo de un componente
   */
  private getEffectivePadding(comp: any): { top: number, right: number, bottom: number, left: number } {
    // Prioridad: paddingAll -> valores individuales
    if (comp.paddingAll !== undefined && comp.paddingAll > 0) {
      return {
        top: comp.paddingAll,
        right: comp.paddingAll,
        bottom: comp.paddingAll,
        left: comp.paddingAll
      };
    }

    return {
      top: comp.padding?.top ?? 0,
      right: comp.padding?.right ?? 0,
      bottom: comp.padding?.bottom ?? 0,
      left: comp.padding?.left ?? 0
    };
  }

  /**
   * Valida hijos en layout row
   */
  private validateRowLayoutChildren(parent: any, availableWidth: number, availableHeight: number): void {
    const gap = parent.gap ?? 8;
    const flexChildren = parent.children.filter((child: any) => child.type !== 'Text');

    if (flexChildren.length === 0) return;

    // Calcular ancho mÃ¡ximo por hijo considerando gaps
    const totalGaps = gap * (flexChildren.length - 1);
    const maxWidthPerChild = (availableWidth - totalGaps) / flexChildren.length;

    flexChildren.forEach((child: any) => {
      let updated = false;
      const currentWidth = child.width ?? 100;
      const currentHeight = child.height ?? 100;

      // Ajustar ancho si excede el espacio disponible
      if (currentWidth > maxWidthPerChild && maxWidthPerChild > 0) {
        child.width = Math.max(20, maxWidthPerChild); // MÃ­nimo 20px
        updated = true;
      }

      // Ajustar altura si excede el espacio disponible
      if (currentHeight > availableHeight && availableHeight > 0) {
        child.height = Math.max(20, availableHeight);
        updated = true;
      }

      if (updated) {
        this.emitChildSizeUpdate(child);
      }
    });
  }

  /**
   * Valida hijos en layout column
   */
  private validateColumnLayoutChildren(parent: any, availableWidth: number, availableHeight: number): void {
    const gap = parent.gap ?? 8;
    const flexChildren = parent.children.filter((child: any) => child.type !== 'Text');

    if (flexChildren.length === 0) return;

    // Calcular altura mÃ¡xima por hijo considerando gaps
    const totalGaps = gap * (flexChildren.length - 1);
    const maxHeightPerChild = (availableHeight - totalGaps) / flexChildren.length;

    flexChildren.forEach((child: any) => {
      let updated = false;
      const currentWidth = child.width ?? 100;
      const currentHeight = child.height ?? 100;

      // Ajustar ancho si excede el espacio disponible
      if (currentWidth > availableWidth && availableWidth > 0) {
        child.width = Math.max(20, availableWidth);
        updated = true;
      }

      // Ajustar altura si excede el espacio disponible
      if (currentHeight > maxHeightPerChild && maxHeightPerChild > 0) {
        child.height = Math.max(20, maxHeightPerChild);
        updated = true;
      }

      if (updated) {
        this.emitChildSizeUpdate(child);
      }
    });
  }
  /**
   * Emite la actualizaciÃ³n de tamaÃ±o del hijo al servidor
   */
  private emitChildSizeUpdate(child: any): void {
    const pageId = this.pages[this.currentPantalla].id;
    this.sokectService.updateComponentProperties(
      this.roomCode,
      pageId,
      child.id,
      {
        width: child.width,
        height: child.height
      }
    );
  }
  /**
   * Valida hijos en layout stack/null (posicionamiento absoluto)
   */
  private validateStackLayoutChildren(
    parent: any,
    availableWidth: number,
    availableHeight: number,
    padding: { top: number, right: number, bottom: number, left: number },
    borderWidth: number
  ): void {
    parent.children.forEach((child: any) => {
      let updated = false;
      const currentWidth = child.width ?? 100;
      const currentHeight = child.height ?? 100;
      const childLeft = child.left ?? 0;
      const childTop = child.top ?? 0;

      // Calcular espacio mÃ¡ximo disponible considerando posiciÃ³n
      const maxWidthFromPosition = availableWidth - childLeft;
      const maxHeightFromPosition = availableHeight - childTop;

      // Ajustar ancho si se sale del contenedor
      if (currentWidth > maxWidthFromPosition && maxWidthFromPosition > 0) {
        child.width = Math.max(20, maxWidthFromPosition);
        updated = true;
      }

      // Ajustar altura si se sale del contenedor
      if (currentHeight > maxHeightFromPosition && maxHeightFromPosition > 0) {
        child.height = Math.max(20, maxHeightFromPosition);
        updated = true;
      }

      if (updated) {
        this.emitChildSizeUpdate(child);
      }
    });
  }

  /**
   * Valida el tamaÃ±o mÃ­nimo del padre basado en sus hijos y layout
   */
  private calculateMinimumParentSizeForLayout(parent: any): ComponentDimensions {
    if (!parent.children || parent.children.length === 0) {
      return this.maxParentSizes.get(parent.id) || {
        width: parent.width ?? 100,
        height: parent.height ?? 100
      };
    }

    const borderWidth = parent.decoration?.border?.width ?? 0;
    const effectivePadding = this.getEffectivePadding(parent);
    const gap = parent.gap ?? 8;

    let requiredWidth = 0;
    let requiredHeight = 0;

    if (parent.childrenLayout === 'row') {
      // En row: sumar anchos + gaps, tomar altura mÃ¡xima
      const flexChildren = parent.children.filter((child: any) => child.type !== 'Text');
      const totalChildrenWidth = flexChildren.reduce((sum: number, child: any) => sum + (child.width ?? 100), 0);
      const totalGaps = gap * Math.max(0, flexChildren.length - 1);
      const maxChildHeight = Math.max(...flexChildren.map((child: any) => child.height ?? 100));

      requiredWidth = totalChildrenWidth + totalGaps + effectivePadding.left + effectivePadding.right + (borderWidth * 2);
      requiredHeight = maxChildHeight + effectivePadding.top + effectivePadding.bottom + (borderWidth * 2);

    } else if (parent.childrenLayout === 'column') {
      // En column: sumar alturas + gaps, tomar ancho mÃ¡ximo
      const flexChildren = parent.children.filter((child: any) => child.type !== 'Text');
      const totalChildrenHeight = flexChildren.reduce((sum: number, child: any) => sum + (child.height ?? 100), 0);
      const totalGaps = gap * Math.max(0, flexChildren.length - 1);
      const maxChildWidth = Math.max(...flexChildren.map((child: any) => child.width ?? 100));

      requiredWidth = maxChildWidth + effectivePadding.left + effectivePadding.right + (borderWidth * 2);
      requiredHeight = totalChildrenHeight + totalGaps + effectivePadding.top + effectivePadding.bottom + (borderWidth * 2);

    } else {
      // Stack/null: calcular basado en posiciones absolutas
      parent.children.forEach((child: any) => {
        const childRight = (child.left || 0) + (child.width || 100);
        const childBottom = (child.top || 0) + (child.height || 100);

        requiredWidth = Math.max(requiredWidth, childRight + effectivePadding.right + borderWidth);
        requiredHeight = Math.max(requiredHeight, childBottom + effectivePadding.bottom + borderWidth);
      });

      // Agregar padding izquierdo/superior y borde
      requiredWidth += effectivePadding.left + borderWidth;
      requiredHeight += effectivePadding.top + borderWidth;
    }

    // Obtener el tamaÃ±o mÃ¡ximo alcanzado hasta ahora
    const currentMaxSize = this.maxParentSizes.get(parent.id) || {
      width: parent.width ?? 100,
      height: parent.height ?? 100
    };

    return {
      width: Math.max(currentMaxSize.width, requiredWidth, 50), // MÃ­nimo 50px
      height: Math.max(currentMaxSize.height, requiredHeight, 50) // MÃ­nimo 50px
    };
  }






  //para el panel derecho encargado de actualizar las propiedades de un widget


  // Agregar este mÃ©todo para manejar cambios de childrenLayout

  updateChildrenLayout(value: string): void {
    if (!this.selectedComponent || !this.roomCode) return;

    const pageId = this.pages[this.currentPantalla].id;
    const comp = this.selectedComponent;

    // Actualizar local
    comp.childrenLayout = value || '';

    // Enviar al servidor
    this.sokectService.updateComponentProperties(
      this.roomCode,
      pageId,
      comp.id,
      { childrenLayout: value || '' }
    );

    // Cuando cambia el layout, necesitamos:
    // 1. Recalcular el tamaÃ±o del contenedor padre
    // 2. Validar y ajustar los hijos
    if (comp.children?.length) {
      setTimeout(() => {
        this.validateAndAdjustChildrenSizes(comp.id);

        // Si tiene padre, tambiÃ©n reajustar
        if (comp.parentId) {
          this.autoResizeParent(comp.parentId);
        }
      }, 0);
    }
  }

  updateProperty(key: string, value: any): void {
    if (!this.selectedComponent || !this.roomCode) return;
    const pageId = this.pages[this.currentPantalla].id;
    const comp = this.selectedComponent;

    // 1) Actualizar local
    const keys = key.split('.');
    let target = comp as any;
    while (keys.length > 1) {
      const k = keys.shift()!;
      if (!(k in target)) target[k] = {};
      target = target[k];
    }
    target[keys[0]] = value;

    // 2) Enviar al servidor
    this.sokectService.updateComponentProperties(
      this.roomCode,
      pageId,
      comp.id,
      { [key]: value }
    );

    // 3) Validaciones especiales segÃºn el tipo de cambio
    if (key === 'width' || key === 'height') {
      // Si cambiaron dimensiones del componente actual
      if (comp.parentId) {
        setTimeout(() => this.autoResizeParent(comp.parentId!), 0);
      }
      if (comp.children?.length) {
        setTimeout(() => this.validateAndAdjustChildrenSizes(comp.id), 0);
      }
    } else if (key === 'childrenLayout') {
      // Usar el mÃ©todo especÃ­fico para childrenLayout
      this.updateChildrenLayout(value);
      return; // Salir temprano ya que updateChildrenLayout ya maneja todo
    } else if (key === 'gap') {
      // Si cambiÃ³ gap, validar hijos
      if (comp.children?.length) {
        setTimeout(() => this.validateAndAdjustChildrenSizes(comp.id), 0);
      }
    }
  }

  updatePaddingProperty(side: 'top' | 'right' | 'bottom' | 'left' | 'paddingAll', value: number): void {
    if (!this.selectedComponent || !this.roomCode) return;

    const pageId = this.pages[this.currentPantalla].id;
    const comp = this.selectedComponent;

    let updates: any = {};

    if (side === 'paddingAll') {
      // Actualizar paddingAll y limpiar padding individual
      comp.paddingAll = value;

      // Si se establece paddingAll, limpiar padding individual
      if (value > 0) {
        delete comp.padding;
        updates = {
          paddingAll: value,
          padding: undefined
        };
      } else {
        updates = { paddingAll: value };
      }
    } else {
      // Actualizar padding individual
      if (!comp.padding) {
        comp.padding = {};
      }

      comp.padding[side] = value;

      // Si se estÃ¡ usando padding individual, limpiar paddingAll
      if (value > 0 && comp.paddingAll !== undefined) {
        delete comp.paddingAll;
        updates = {
          padding: comp.padding,
          paddingAll: undefined
        };
      } else {
        updates = {
          [`padding.${side}`]: value
        };
      }
    }

    // Enviar al servidor
    this.sokectService.updateComponentProperties(
      this.roomCode,
      pageId,
      comp.id,
      updates
    );

    // Validar y ajustar hijos despuÃ©s del cambio de padding
    if (comp.children?.length) {
      setTimeout(() => this.validateAndAdjustChildrenSizes(comp.id), 0);
    }

    // Si tiene padre, tambiÃ©n podrÃ­a necesitar reajuste
    if (comp.parentId) {
      setTimeout(() => this.autoResizeParent(comp.parentId!), 0);
    }
  }
  getEventValue(event: Event): string {
    const target = event.target as HTMLInputElement | null;
    return target?.value || '';
  }
  getInputValue(event: Event): string {
    return (event.target as HTMLInputElement)?.value || '';
  }

  getInputNumberValue(event: Event): number {
    const value = (event.target as HTMLInputElement)?.value;
    return value !== undefined ? +value : 0;
  }
  //DropdownButton
  dropdownNewOption: string = '';
  onDropdownChange(comp: CanvasComponent, newValue: string) {
    comp.selectedOption = newValue;
    // Si quieres persistir este cambio en el servidor, descomenta la lÃ­nea siguiente:
    this.updateProperty('selectedOption', newValue);
  }
  addDropdownOption() {
    if (
      !this.selectedComponent ||
      this.selectedComponent.type !== 'DropdownButton'
    )
      return;

    const opts = this.selectedComponent.options || [];
    if (this.dropdownNewOption.trim()) {
      opts.push(this.dropdownNewOption.trim());
      // Enviamos el arreglo completo de opciones actualizado
      this.updateProperty('options', opts);
      // Limpiamos el input
      this.dropdownNewOption = '';
    }
  }

  removeDropdownOption(optToRemove: string) {
    if (
      !this.selectedComponent ||
      this.selectedComponent.type !== 'DropdownButton'
    )
      return;

    const opts = (this.selectedComponent.options || []).filter(
      (o) => o !== optToRemove
    );
    this.updateProperty('options', opts);
  }
  onDropdownOptionInput(index: number, event: Event) {
    const inputValue = (event.target as HTMLInputElement).value;

    if (
      !this.selectedComponent ||
      this.selectedComponent.type !== 'DropdownButton' ||
      !Array.isArray(this.selectedComponent.options)
    ) {
      return;
    }

    // Modificamos el array existente en lugar de crear uno nuevo
    this.selectedComponent.options[index] = inputValue;

    // Actualizamos usando el mÃ©todo existente
    const updates = { options: this.selectedComponent.options };
    this.sokectService.updateComponentProperties(
      this.roomCode,
      this.pages[this.currentPantalla].id,
      this.selectedComponent.id,
      updates
    );
  }
  trackByFn(index: number, item: any): any {
    return index; // O usa un ID Ãºnico si tienes
  }
  //fin

  handleNavigateToChange(event: Event): void {
    const value = (event.target as HTMLSelectElement).value;
    if (!this.selectedComponent) return;

    if (value === 'custom') {
      this.updateProperty('navigateTo', 'custom');
    } else {
      this.updateProperty('navigateTo', value);
      this.pantallaCustomRoute = value;
    }
  }
  getRutaPantalla(nombre: string): string {
    return '/' + nombre.toLowerCase().replace(/ /g, '');
  }

  onCheckboxToggle(comp: CanvasComponent, event: Event) {
    // Obtiene si estÃ¡ chequeado o no
    const newChecked = (event.target as HTMLInputElement).checked;
    // Actualiza localmente (para que el cambio se vea al vuelo)
    comp.checked = newChecked;

    // EnvÃ­a la actualizaciÃ³n al servidor para sincronizar con otros usuarios
    const updates: any = { checked: newChecked };

    const pageId = this.pages[this.currentPantalla].id;
    const componentId = comp.id;
    this.sokectService.updateComponentProperties(
      this.roomCode,
      pageId,
      componentId,
      updates
    );
  }

  simulateCheckboxClick(comp: CanvasComponent, event: MouseEvent): void {
    if (!this.isPreviewMode) return;

    // Crear un evento sintÃ©tico para simular el cambio del checkbox
    const syntheticEvent = {
      target: {
        checked: !comp.checked,
      } as HTMLInputElement,
    } as unknown as Event;

    // Usar tu mÃ©todo existente
    this.onCheckboxToggle(comp, syntheticEvent);

    // Si hay una acciÃ³n definida, ejecutarla
    if (comp.onChangeAction && comp.onChangeAction.trim()) {
      this.executeCheckboxAction(comp, !comp.checked);
    }
  }

  private executeCheckboxAction(
    comp: CanvasComponent,
    newCheckedState: boolean
  ): void {
    const actionName = comp.onChangeAction;
    if (!actionName) return;

    console.log(
      `Ejecutando acciÃ³n: ${actionName} - Checkbox ${newCheckedState ? 'marcado' : 'desmarcado'
      }`
    );

    // Ejemplo de acciones predefinidas
    switch (actionName.toLowerCase()) {
      case 'mostrarAlert':
        alert(
          `Checkbox ${newCheckedState ? 'marcado' : 'desmarcado'}: ${comp.text}`
        );
        break;
      case 'console':
        console.log(`Checkbox ${comp.text}: ${newCheckedState}`);
        break;
      // Agregar mÃ¡s casos segÃºn necesites
      default:
        // Intentar ejecutar funciÃ³n personalizada si existe
        if (typeof (window as any)[actionName] === 'function') {
          (window as any)[actionName](newCheckedState, comp);
        }
        break;
    }
  }

  recalculateCheckboxDimensions(): void {
    if (!this.selectedComponent || this.selectedComponent.type !== 'Checkbox')
      return;

    const checkSize = this.selectedComponent.checkSize || 24;
    const labelGap = this.selectedComponent.labelGap || 8;
    const estimatedTextWidth = (this.selectedComponent.text?.length || 8) * 8; // EstimaciÃ³n bÃ¡sica

    let newWidth = checkSize;
    let newHeight = checkSize;

    if (
      this.selectedComponent.labelPosition === 'right' ||
      this.selectedComponent.labelPosition === 'left'
    ) {
      newWidth = checkSize + labelGap + estimatedTextWidth;
    } else if (
      this.selectedComponent.labelPosition === 'top' ||
      this.selectedComponent.labelPosition === 'bottom'
    ) {
      newHeight = checkSize + labelGap + 20; // 20px estimado para el texto
      newWidth = Math.max(checkSize, estimatedTextWidth);
    }

    this.updateProperty('width', newWidth);
    this.updateProperty('height', newHeight);
  }

  //metodos necesario para que un widget padre nunca sea mas pequeÃ±o que sus hijos

  // Nueva propiedad para almacenar tamaÃ±os originales de padres
  private originalParentSizes: Map<string, ComponentDimensions> = new Map();
  private maxParentSizes: Map<string, ComponentDimensions> = new Map();
  // 3. NUEVO MÃ‰TODO para calcular el tamaÃ±o mÃ­nimo requerido por los hijos
  private calculateMinimumParentSize(parent: CanvasComponent): ComponentDimensions {
    if (!parent.children || parent.children.length === 0) {
      // Si no hay hijos, mantener el tamaÃ±o mÃ¡ximo alcanzado
      return this.maxParentSizes.get(parent.id) || {
        width: parent.width ?? 100,
        height: parent.height ?? 100
      };
    }

    let maxRequiredWidth = 0;
    let maxRequiredHeight = 0;

    // Calcular el espacio mÃ­nimo requerido basado en los hijos
    parent.children.forEach(child => {
      const childWidth = child.width ?? 100;   // Valor por defecto para child.width
      const childHeight = child.height ?? 100; // Valor por defecto para child.height

      const childRight = (child.left || 0) + childWidth;
      const childBottom = (child.top || 0) + childHeight;

      maxRequiredWidth = Math.max(maxRequiredWidth, childRight);
      maxRequiredHeight = Math.max(maxRequiredHeight, childBottom);
    });

    // Obtener el tamaÃ±o mÃ¡ximo alcanzado hasta ahora
    const currentMaxSize = this.maxParentSizes.get(parent.id) || {
      width: parent.width ?? 100,   // Valor por defecto si width es undefined
      height: parent.height ?? 100  // Valor por defecto si height es undefined
    };

    // El padre debe ser al menos tan grande como:
    // 1. Su tamaÃ±o mÃ¡ximo alcanzado anteriormente
    // 2. El espacio requerido por los hijos actuales
    const requiredWidth = Math.max(currentMaxSize.width, maxRequiredWidth + 10); // +10 padding
    const requiredHeight = Math.max(currentMaxSize.height, maxRequiredHeight + 10); // +10 padding

    return {
      width: requiredWidth,
      height: requiredHeight
    };
  }

  // MÃ‰TODO para ajustar automÃ¡ticamente el tamaÃ±o del padre
  private autoResizeParent(parentId: string): void {
    if (!parentId || !this.roomCode) return;

    const page = this.pages[this.currentPantalla];
    const parent = this.findComponentById(page.components, parentId);

    if (!parent) return;

    // Inicializar el tamaÃ±o mÃ¡ximo si no existe
    if (!this.maxParentSizes.has(parent.id)) {
      this.maxParentSizes.set(parent.id, {
        width: parent.width ?? 100,
        height: parent.height ?? 100
      });
    }

    // Calcular nuevo tamaÃ±o considerando el layout
    const newSize = this.calculateMinimumParentSizeForLayout(parent);

    // Actualizar el tamaÃ±o mÃ¡ximo alcanzado
    const currentMaxSize = this.maxParentSizes.get(parent.id)!;
    const updatedMaxSize = {
      width: Math.max(currentMaxSize.width, newSize.width),
      height: Math.max(currentMaxSize.height, newSize.height)
    };

    this.maxParentSizes.set(parent.id, updatedMaxSize);

    const currentParentWidth = parent.width ?? 100;
    const currentParentHeight = parent.height ?? 100;

    // Solo actualizar si el tamaÃ±o cambiÃ³ (solo puede crecer)
    if (currentParentWidth < updatedMaxSize.width || currentParentHeight < updatedMaxSize.height) {
      parent.width = updatedMaxSize.width;
      parent.height = updatedMaxSize.height;

      const updates = {
        width: updatedMaxSize.width,
        height: updatedMaxSize.height
      };

      this.sokectService.updateComponentProperties(
        this.roomCode,
        page.id,
        parent.id,
        updates
      );

      // Validar hijos despuÃ©s del cambio de tamaÃ±o del padre
      setTimeout(() => this.validateAndAdjustChildrenSizes(parent.id), 0);
    }
  }
  resetParentToOriginalSize(parentId: string): void {
    const originalSize = this.originalParentSizes.get(parentId);
    if (!originalSize || !this.roomCode) return;

    const page = this.pages[this.currentPantalla];
    const parent = this.findComponentById(page.components, parentId);

    if (!parent) return;

    // Solo resetear si no hay hijos que requieran mÃ¡s espacio
    const requiredSize = this.calculateMinimumParentSize(parent);

    if (requiredSize.width <= originalSize.width && requiredSize.height <= originalSize.height) {
      parent.width = originalSize.width;
      parent.height = originalSize.height;

      const updates = {
        width: originalSize.width,
        height: originalSize.height
      };

      this.sokectService.updateComponentProperties(
        this.roomCode,
        page.id,
        parent.id,
        updates
      );
    }
  }
  //border
  // 5.b) NUEVO MÃ‰TODO para ajustar automÃ¡ticamente el tamaÃ±o de los hijos
  private autoShrinkChildren(parentId: string): void {
    if (!parentId || !this.roomCode) return;
    const page = this.pages[this.currentPantalla];
    const parent = this.findComponentById(page.components, parentId);
    if (!parent || !parent.children?.length) return;

    const padding = 10; // el mismo padding que usas en autoResizeParent
    const parentWidth = parent.width ?? 100;   // Valor por defecto para parent.width
    const parentHeight = parent.height ?? 100; // Valor por defecto para parent.height

    parent.children.forEach(child => {
      let updated = false;
      const childWidth = child.width ?? 100;   // Valor por defecto para child.width
      const childHeight = child.height ?? 100; // Valor por defecto para child.height

      // ancho mÃ¡ximo permitido por el padre
      const maxW = parentWidth - (child.left || 0) - padding;
      if (childWidth > maxW) {
        child.width = Math.max(0, maxW);
        updated = true;
      }

      // alto mÃ¡ximo permitido por el padre
      const maxH = parentHeight - (child.top || 0) - padding;
      if (childHeight > maxH) {
        child.height = Math.max(0, maxH);
        updated = true;
      }

      // si cambiamos algo, enviamos la actualizaciÃ³n al servidor
      if (updated) {
        this.sokectService.updateComponentProperties(
          this.roomCode,
          page.id,
          child.id,
          { width: child.width, height: child.height }
        );
      }
    });
  }
  //fin border
  downloadAngularProject() {
    //const url = `https://back-sw1.onrender.com/api/export/flutter/${this.roomCode}`;
    const url = `http://localhost:3000/api/export/flutter/${this.roomCode}`;
    window.open(url, '_blank'); // Abre la descarga del zip en otra pestaÃ±a
  }

  /**
   * Cargar JSON de ejemplo local y sincronizar con BD
   */
  cargarJsonEjemploLocal(): void {
    const jsonEjemplo: CanvasComponent[] = [
      {
        "id": "34844b26-f795-4e11-a654-ed0b9e5e4eed",
        "type": "AppBar",
        "top": 0,
        "left": 0,
        "width": 360,
        "height": 70,
        "decoration": {
          "color": "#2196f3",
          "border": {
            "color": "#000000",
            "width": 0
          },
          "borderRadius": 0
        },
        "children": [],
        "parentId": null
      },
      {
        "id": "f4bb8bca-041b-4b15-a49a-34b3e7134bde",
        "type": "Container",
        "top": 72,
        "left": 98,
        "width": 116,
        "height": 104,
        "decoration": {
          "color": "#3cb6c4",
          "border": {
            "color": "#b56481",
            "width": 1
          },
          "borderRadius": 5
        },
        "children": [],
        "parentId": null,
        "childrenLayout": "",
        "gap": 8
      },
      {
        "id": "7284a3de-716a-458c-a2bf-b430eead1f52",
        "type": "DropdownButton",
        "top": 390,
        "left": 78,
        "width": 120,
        "height": 40,
        "decoration": {
          "color": "#800040",
          "border": {
            "color": "#000000",
            "width": 1
          },
          "borderRadius": 4
        },
        "options": [
          "OpciÃ³n 1e",
          "OpciÃ³n 2sd"
        ],
        "selectedOption": "OpciÃ³n 1",
        "children": [],
        "parentId": null
      },
      {
        "id": "afa51736-657e-4b7f-a002-8b94dc41acf8",
        "type": "Text",
        "text": "TÃ­tulo",
        "fontSize": 16,
        "autoSize": true,
        "width": 44,
        "height": 30,
        "top": 241,
        "left": 214,
        "children": [],
        "parentId": null
      }
    ];

    // Obtener el ID de la pÃ¡gina actual
    const pageId = this.pages[this.currentPantalla].id;

    // Limpiar componentes actuales localmente (opcional, para pruebas)
    // this.pages[this.currentPantalla].components = [];

    // Agregar cada componente usando el servicio socket para sincronizar
    jsonEjemplo.forEach((component, index) => {
      // Generar nuevo ID para evitar conflictos si se ejecuta mÃºltiples veces
      const componentWithNewId = {
        ...component,
        id: uuidv4()
      };

      // Agregar con un pequeÃ±o delay para evitar conflictos
      setTimeout(() => {
        this.sokectService.addCanvasComponent(this.roomCode, pageId, componentWithNewId);
      }, index * 100); // 100ms entre cada componente
    });

    console.log('ðŸŽ¯ Cargando JSON de ejemplo...', jsonEjemplo.length, 'componentes');
  }

  submitQuestion() {
    if (this.questionText.trim()) {
      this.showQuestionModal = false;
      const body = { question: this.questionText };
      this.makeHttpRequest();
      this.questionText = ''; // Limpiar el texto despuÃ©s de enviar
    }
  }

  makeHttpRequest() {
    const body = { question: this.questionText };
    this.http.post('http://localhost:3000/api/openai/query', body).subscribe({
    // this.http.post('https://v9k5scrk-5000.brs.devtunnels.ms/query', body).subscribe({
      next: (response: any) => {
        try {
          // Parsear la respuesta y asignarla a jsonEjemplo
          const components = JSON.parse(response.response);

          // Obtener el ID de la pÃ¡gina actual
          const pageId = this.pages[this.currentPantalla].id;

          // ðŸ§¹ PASO 1: Limpiar la pantalla actual usando socket service
          this.sokectService.clearPage(this.roomCode, pageId);

          // ðŸŽ¯ PASO 2: Agregar nuevos componentes despuÃ©s de un pequeÃ±o delay
          // para asegurar que la limpieza se complete primero
          setTimeout(() => {
            components.forEach((component: any, index: number) => {
              // Generar nuevo ID para evitar conflictos
              const componentWithNewId = {
                ...component,
                id: uuidv4()
              };

              // Agregar con un pequeÃ±o delay para evitar conflictos
              setTimeout(() => {
                this.sokectService.addCanvasComponent(this.roomCode, pageId, componentWithNewId);
              }, index * 100); // 100ms entre cada componente
            });
          }, 200); // 200ms de delay inicial para que la limpieza se complete
          this.showResponseModal = true;
          this.httpResponse = `DiseÃ±o cargado exitosamente - ${components.length} componentes agregados`;
          console.log('ðŸ¤– Componentes de IA cargados:', components.length, 'elementos');
          console.log('ðŸ§¹ Pantalla limpiada y nuevos componentes agregados');

        } catch (error) {
          this.httpResponse = "Error al procesar la respuesta: " + error;
          this.showResponseModal = true;
        }
      },
      error: (error) => {
        this.httpResponse = error;
        this.showResponseModal = true;
      }
    });
  }

  onImageSelected(event: Event) {
    const input = event.target as HTMLInputElement;
    if (input.files && input.files.length > 0) {
      this.selectedImage = input.files[0];
      this.imagePrompt = '';
      // this.showImageModal = true;
      // this.makeHttpRequest2(this.imagePrompt);
      this.sendImageToBackend();
    }
  }

  makeHttpRequest2(promptText: string) {
    const body = { question: promptText };
    this.http.post('http://localhost:3000/api/openai/query', body).subscribe({
    // this.http.post('https://v9k5scrk-5000.brs.devtunnels.ms/query', body).subscribe({
      next: (response: any) => {
        try {
          const components = JSON.parse(response.response);
          const pageId = this.pages[this.currentPantalla].id;

          this.sokectService.clearPage(this.roomCode, pageId);

          setTimeout(() => {
            components.forEach((component: any, index: number) => {
              const componentWithNewId = {
                ...component,
                id: uuidv4()
              };

              setTimeout(() => {
                this.sokectService.addCanvasComponent(this.roomCode, pageId, componentWithNewId);
              }, index * 100);
            });
          }, 200);

          this.showResponseModal = true;
          this.httpResponse = `DiseÃ±o cargado exitosamente - ${components.length} componentes agregados`;
          console.log('ðŸ¤– Componentes de IA cargados:', components.length, 'elementos');
          console.log('ðŸ§¹ Pantalla limpiada y nuevos componentes agregados');

        } catch (error) {
          this.httpResponse = "Error al procesar la respuesta: " + error;
          this.showResponseModal = true;
        }
      },
      error: (error) => {
        this.httpResponse = error;
        this.showResponseModal = true;
      }
    });
  }

  sendImageToBackend() {
    if (!this.selectedImage) return;
    console.log('Enviando imagen al backend...');
    const formData = new FormData();
    formData.append('image', this.selectedImage);
    formData.append('prompt', this.imagePrompt || 'Describe la imagen');

    this.http.post<any>('http://localhost:3000/api/openai/analyze-image', formData).subscribe({
    // this.http.post<any>('https://v9k5scrk-5000.brs.devtunnels.ms/analyze-image', formData).subscribe({
      next: (response) => {
        this.httpResponse = response.response;
        // this.showResponseModal = true;
        this.showImageModal = false;
        this.makeHttpRequest2(response.response);
      },
      error: (error) => {
        this.httpResponse = error.error?.error || 'Error al analizar la imagen';
        this.showResponseModal = true;
        this.showImageModal = false;
      }
    });
  }

  openQuestionModal() {
    this.questionText = '';
    this.showQuestionModal = true;
  }

  closeQuestionModal() {
    this.showQuestionModal = false;
    this.questionText = '';
  }

  // MÃ©todo para alternar la grabaciÃ³n de voz y reconocimiento de voz
  toggleRecording(): void {
    if (this.isRecording) {
      // Detener grabaciÃ³n
      this.isRecording = false;
      this.isProcessingAudio = true;
      if (this.recognition) {
        this.recognition.stop();
      }
    } else {
      // Iniciar grabaciÃ³n
      const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;
      if (!SpeechRecognition) {
        alert('El reconocimiento de voz no es compatible con este navegador. Prueba en Chrome.');
        return;
      }
      this.recognition = new SpeechRecognition();
      this.recognition.lang = 'es-ES';
      this.recognition.interimResults = false;
      this.recognition.maxAlternatives = 1;
      this.isRecording = true;
      this.isProcessingAudio = false;
      this.questionText = '';

      this.recognition.onresult = (event: any) => {
        const transcript = event.results[0][0].transcript;
        this.questionText = transcript;
        this.isProcessingAudio = false;
        this.isRecording = false;
        this.cdr.detectChanges();
      };
      this.recognition.onerror = (event: any) => {
        this.isProcessingAudio = false;
        this.isRecording = false;
        this.questionText = '';
        alert('Error en el reconocimiento de voz: ' + event.error);
        this.cdr.detectChanges();
      };
      this.recognition.onend = () => {
        this.isProcessingAudio = false;
        this.isRecording = false;
        this.cdr.detectChanges();
      };
      this.recognition.start();
    }
  }
}
